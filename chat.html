<html>
  <head>
    <meta charset="UTF-8">
    <title>Chat JS Only</title>
  </head>
  <body>
    <script type="application/javascript">
      // Configuración inicial del tema
      let currentTheme = localStorage.getItem('theme') || 'light';
      function applyTheme(theme) {
        document.body.style.backgroundColor = theme === 'dark' ? '#121212' : '#ffffff';
        document.body.style.color = theme === 'dark' ? '#f0f0f0' : '#000000';
      }
      applyTheme(currentTheme);

      // Crear contenedor principal usando flex para ocupar todo el alto de la ventana
      const appContainer = document.createElement('div');
      appContainer.style.display = 'flex';
      appContainer.style.flexDirection = 'column';
      appContainer.style.height = '100vh';
      appContainer.style.fontFamily = 'Arial, sans-serif';
      document.body.appendChild(appContainer);

      // Header con título y botón para cambiar tema
      const header = document.createElement('div');
      header.style.padding = '10px';
      header.style.display = 'flex';
      header.style.justifyContent = 'space-between';
      header.style.alignItems = 'center';
      header.style.borderBottom = '1px solid #ccc';
      const title = document.createElement('h2');
      title.innerText = 'Chat JS Only';
      title.style.margin = '0';
      header.appendChild(title);
      const themeButton = document.createElement('button');
      themeButton.innerText = 'Toggle Theme';
      themeButton.style.padding = '5px 10px';
      header.appendChild(themeButton);
      appContainer.appendChild(header);

      themeButton.addEventListener('click', () => {
        currentTheme = currentTheme === 'light' ? 'dark' : 'light';
        applyTheme(currentTheme);
        localStorage.setItem('theme', currentTheme);
      });

      // Contenedor para los mensajes con scroll
      const messagesContainer = document.createElement('div');
      messagesContainer.style.flex = '1';
      messagesContainer.style.overflowY = 'auto';
      messagesContainer.style.padding = '10px';
      messagesContainer.style.boxSizing = 'border-box';
      appContainer.appendChild(messagesContainer);

      // Contenedor del campo de entrada, ubicado en la parte inferior
      const inputContainer = document.createElement('div');
      inputContainer.style.display = 'flex';
      inputContainer.style.padding = '10px';
      inputContainer.style.borderTop = '1px solid #ccc';
      inputContainer.style.alignItems = 'center';
      appContainer.appendChild(inputContainer);

      // Campo de entrada con límite de 140 caracteres
      const messageInput = document.createElement('input');
      messageInput.type = 'text';
      messageInput.placeholder = 'Escribe tu mensaje (máximo 140 caracteres)...';
      messageInput.maxLength = 140;
      messageInput.style.flex = '1';
      messageInput.style.padding = '10px';
      messageInput.style.fontSize = '16px';
      inputContainer.appendChild(messageInput);

      // Botón para enviar el mensaje (alternativa al uso de Enter)
      const sendButton = document.createElement('button');
      sendButton.innerText = 'Enviar';
      sendButton.style.marginLeft = '10px';
      sendButton.style.padding = '10px';
      inputContainer.appendChild(sendButton);

      // URL del API del chat
      const apiUrl = 'https://chat.devng.online/chats';

      // Función para animar la aparición de cada mensaje (fade in)
      function animateMessage(element) {
        element.style.opacity = 0;
        let last = +new Date();
        const tick = function() {
          element.style.opacity = +element.style.opacity + (new Date() - last) / 400;
          last = +new Date();
          if (+element.style.opacity < 1) {
            requestAnimationFrame(tick);
          } else {
            element.style.opacity = 1;
          }
        };
        tick();
      }

      // Función para crear el elemento de mensaje a partir del objeto mensaje
      function createMessageElement(message) {
        // Uso de deconstrucción para extraer propiedades (suponiendo id y text)
        const { id, text } = message;
        const messageEl = document.createElement('div');
        messageEl.style.marginBottom = '15px';
        messageEl.style.padding = '10px';
        messageEl.style.border = '1px solid #ddd';
        messageEl.style.borderRadius = '5px';
        messageEl.style.backgroundColor = currentTheme === 'dark' ? '#1e1e1e' : '#f9f9f9';
        messageEl.innerText = text;

        // Detectar links a imágenes y crear preview
        const imageRegex = /(https?:\/\/\S+\.(jpg|jpeg|png|gif))/i;
        const imgMatch = text.match(imageRegex);
        if (imgMatch) {
          const imgUrl = imgMatch[1];
          const imgEl = document.createElement('img');
          imgEl.src = imgUrl;
          imgEl.style.maxWidth = '100%';
          imgEl.style.display = 'block';
          imgEl.style.marginTop = '10px';
          messageEl.appendChild(imgEl);
        }

        // Detectar links a páginas web (no imágenes) y crear un preview simple
        const urlRegex = /(https?:\/\/[^\s]+)/g;
        const urls = text.match(urlRegex);
        if (urls) {
          urls.forEach(url => {
            if (!url.match(/\.(jpg|jpeg|png|gif)$/i)) {
              const linkPreview = document.createElement('div');
              linkPreview.style.border = '1px solid #aaa';
              linkPreview.style.padding = '5px';
              linkPreview.style.marginTop = '10px';
              linkPreview.style.borderRadius = '3px';
              // Enlace clickable que abre en nueva pestaña
              const linkEl = document.createElement('a');
              linkEl.href = url;
              linkEl.target = '_blank';
              linkEl.innerText = url;
              linkPreview.appendChild(linkEl);
              messageEl.appendChild(linkPreview);
            }
          });
        }

        animateMessage(messageEl);
        return messageEl;
      }

      // Función asíncrona para obtener los mensajes del servidor
      async function fetchMessages() {
        try {
          const response = await fetch(apiUrl);
          const messages = await response.json();
          // Guardar posición actual del scroll
          const scrollTopBefore = messagesContainer.scrollTop;
          // Limpiar mensajes actuales
          messagesContainer.innerHTML = '';
          messages.forEach(msg => {
            const messageEl = createMessageElement(msg);
            messagesContainer.appendChild(messageEl);
          });
          // Restaurar la posición del scroll
          messagesContainer.scrollTop = scrollTopBefore;
        } catch (error) {
          console.error('Error al obtener mensajes:', error);
        }
      }

      // Función asíncrona para enviar un mensaje al servidor
      async function sendMessage(text) {
        try {
          // Creación del objeto payload usando deconstrucción (para reutilizar estructura)
          const payload = { text };
          const response = await fetch(apiUrl, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          if (response.ok) {
            // Actualizar el chat tras el envío
            await fetchMessages();
          } else {
            console.error('Error al enviar mensaje:', response.statusText);
          }
        } catch (error) {
          console.error('Error al enviar mensaje:', error);
        }
      }

      // Enviar mensaje con la tecla "Enter"
      messageInput.addEventListener('keydown', (event) => {
        if (event.key === 'Enter') {
          event.preventDefault();
          const text = messageInput.value.trim();
          if (text !== '') {
            sendMessage(text);
            messageInput.value = '';
          }
        }
      });

      // También se envía al hacer clic en el botón "Enviar"
      sendButton.addEventListener('click', () => {
        const text = messageInput.value.trim();
        if (text !== '') {
          sendMessage(text);
          messageInput.value = '';
        }
      });

      // Obtener mensajes al iniciar y refrescarlos cada 5 segundos
      fetchMessages();
      setInterval(fetchMessages, 5000);
    </script>
  </body>
</html>
